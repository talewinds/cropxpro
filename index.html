<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI StickerGen â€” Cartoon, Text & Emoji for WhatsApp/Instagram</title>
  <meta name="description" content="Instantly convert photos into shareable stickers. AI server + fast in-browser fallback cartoonifier, transparent PNG output, sticker packs." />
  <meta name="keywords" content="sticker maker, whatsapp stickers, cartoonify, transparent png, ai sticker, webp support" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- JSZip (sticker pack ZIP) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" integrity="sha512-j6P/8o4HnOQ5pKc1uM3u1z8zrH6V7gYQHc6Bz1w1lC1mFfM6a3sZq+Jp/5lX0r3f0YQkzktm7ERkF7u6dVx7xA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <style>
    body { font-family: 'Inter', system-ui, -apple-system, "Helvetica Neue", Arial; background:#f4f7f9; }
    .card { box-shadow: 0 6px 18px rgba(15,23,42,0.06); border-radius: 14px; }
    .preview-box { height: 420px; } /* shortened vertical preview */
    #stickerCanvas { border-radius: 12px; display:block; }
    @media (max-width:768px) { .preview-box { height:360px } }
  </style>

  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'primary-blue': '#10b981',
            'primary-dark': '#064e3b'
          }
        }
      }
    }
  </script>
</head>
<body class="p-4 md:p-8">

  <div class="container mx-auto max-w-6xl">
    <header class="text-center mb-6">
      <h1 class="text-4xl font-extrabold text-primary-dark mb-1">ðŸš€ StickerGen AI</h1>
      <p class="text-gray-600">Fast stickers for WhatsApp & Instagram â€” server AI + fallback cartoonifier.</p>
    </header>

    <div class="ad-unit h-24 md:h-28 bg-gray-100 rounded-lg flex items-center justify-center mb-6 card border border-gray-200">
      <strong class="text-gray-500">AD SENSE UNIT 1 (728x90 / Adaptive)</strong>
    </div>

    <div class="grid lg:grid-cols-3 gap-8">
      <!-- Controls -->
      <div class="lg:col-span-1 card p-6">
        <h2 class="text-2xl font-semibold mb-4">1 â€” Upload & Customize</h2>

        <label class="block text-sm font-medium text-gray-700 mb-2">Select an Image (PNG/JPG/WEBP)</label>
        <input id="fileInput" type="file" accept="image/png,image/jpeg,image/webp" class="w-full text-sm p-2 mb-2 rounded-lg border border-gray-300" />
        <p id="fileNameDisplay" class="text-xs text-gray-500 italic mb-3">No file selected.</p>

        <div class="mb-3">
          <label class="text-sm font-medium text-gray-700">Sticker Type</label>
          <div class="flex gap-2 mt-2">
            <label class="flex items-center gap-2 p-2 bg-gray-100 rounded-lg cursor-pointer"><input name="stickerType" type="radio" value="cartoon" checked onchange="updateControls()" /> <span>âœ¨ AI Cartoon</span></label>
            <label class="flex items-center gap-2 p-2 bg-gray-100 rounded-lg cursor-pointer"><input name="stickerType" type="radio" value="text" onchange="updateControls()" /> <span>ðŸ’¬ Text</span></label>
            <label class="flex items-center gap-2 p-2 bg-gray-100 rounded-lg cursor-pointer"><input name="stickerType" type="radio" value="emoji" onchange="updateControls()" /> <span>ðŸ˜‚ Emoji</span></label>
          </div>
        </div>

        <div id="customizationSection" class="space-y-3 mb-4">
          <div id="textInputGroup" class="hidden">
            <label class="text-sm font-medium">Sticker Text (max 20 char)</label>
            <input id="stickerText" maxlength="20" class="w-full p-2 border rounded-lg" placeholder="E.g., HELLO!" />
            <label class="text-xs text-gray-500 mt-1">Short uppercase text works best.</label>
          </div>

          <div id="emojiInputGroup" class="hidden">
            <label class="text-sm font-medium">Emoji</label>
            <input id="stickerEmoji" maxlength="2" class="w-full p-2 border rounded-lg" placeholder="ðŸ”¥ or ðŸ˜Š" />
          </div>

          <div>
            <label class="text-sm font-medium">Scale</label>
            <input id="scaleRange" type="range" min="0.6" max="1.4" step="0.01" value="1" class="w-full" />
            <div class="flex items-center gap-3 text-xs text-gray-600 mt-1">
              <label class="flex items-center gap-2"><input id="outlineToggle" type="checkbox" /> Outline</label>
              <label class="flex items-center gap-2 text-xs">Thickness <input id="outlineThickness" type="range" min="0" max="24" value="12" class="w-24" /></label>
            </div>
          </div>
        </div>

        <div class="mb-4">
          <button id="generateBtn" onclick="prepareAndGenerate()" class="w-full py-3 font-bold bg-primary-blue text-white rounded-xl disabled:opacity-50 flex items-center justify-center gap-2">
            <svg id="generateIcon" class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
            <svg id="loadingSpinner" class="animate-spin w-5 h-5 hidden" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path></svg>
            <span id="generateText">Generate Sticker</span>
          </button>
          <p id="statusMessage" class="text-center text-sm mt-2 text-gray-600 h-6"></p>
        </div>

        <div id="actionButtons" class="hidden flex gap-3">
          <button id="downloadBtn" onclick="downloadSticker()" class="flex-1 py-2 bg-gray-100 rounded-lg">Download PNG</button>
          <button id="addToPackBtn" onclick="addToPack()" class="flex-1 py-2 bg-yellow-500 text-white rounded-lg">âž• Add to Pack</button>
          <button id="shareBtn" onclick="shareSticker()" class="flex-1 py-2 bg-green-500 text-white rounded-lg">Share</button>
        </div>

        <div class="mt-4 space-y-2 text-xs text-gray-600">
          <div class="flex justify-between"><span>Pack items:</span><strong id="packCount">0</strong></div>
          <div class="flex gap-2">
            <button id="downloadPackBtn" onclick="downloadPack()" class="flex-1 py-2 bg-indigo-600 text-white rounded-lg">Download Pack (ZIP)</button>
            <button onclick="clearPack()" class="py-2 px-3 bg-gray-200 rounded-lg">Clear</button>
          </div>
          <div class="text-xxs text-gray-500 mt-2">Tip: App runs locally if no API key is configured. Add your Gemini key to use server AI.</div>
        </div>
      </div>

      <!-- Preview + Ads -->
      <div class="lg:col-span-2 space-y-6">
        <div class="card p-4 preview-box">
          <div class="flex items-center justify-between mb-3 px-2">
            <h3 class="text-lg font-semibold">2 â€” Sticker Preview</h3>
            <div class="text-sm text-gray-500">Canvas: 512Ã—512 (export)</div>
          </div>

          <div class="relative h-full flex items-center justify-center bg-gray-100 rounded-xl p-3">
            <canvas id="stickerCanvas" width="512" height="512" class="shadow-inner"></canvas>
            <div id="initialPrompt" class="absolute text-center text-gray-500 pointer-events-none">
              <svg class="w-14 h-14 mx-auto mb-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
              <p>Upload a photo and click <strong>Generate Sticker</strong>.</p>
            </div>
          </div>
        </div>

        <div class="ad-unit h-44 bg-gray-100 rounded-xl flex items-center justify-center card border border-gray-200">
          <strong class="text-gray-500">AD SENSE UNIT 2 (336x280 / Native)</strong>
        </div>
      </div>
    </div>

    <footer class="mt-8 p-4 card">
      <div class="flex justify-between items-center">
        <div>
          <h4 class="font-semibold">Privacy</h4>
          <p class="text-sm text-gray-600">Images are processed client-side when possible. If server AI is used, do not store images â€” remove API key for fully client-side flow.</p>
        </div>
        <div class="text-sm text-gray-500">Last updated: Nov 29, 2025</div>
      </div>
    </footer>
  </div>

  <script>
  /********** Main Script: StickerGen AI (complete) **********/
  // Elements
  const canvas = document.getElementById('stickerCanvas');
  const ctx = canvas.getContext('2d');
  const fileInput = document.getElementById('fileInput');
  const generateBtn = document.getElementById('generateBtn');
  const actionButtons = document.getElementById('actionButtons');
  const statusMessage = document.getElementById('statusMessage');
  const loadingSpinner = document.getElementById('loadingSpinner');
  const generateIcon = document.getElementById('generateIcon');
  const generateText = document.getElementById('generateText');
  const initialPrompt = document.getElementById('initialPrompt');
  const fileNameDisplay = document.getElementById('fileNameDisplay');

  // Controls
  const textInputGroup = document.getElementById('textInputGroup');
  const emojiInputGroup = document.getElementById('emojiInputGroup');
  const stickerText = document.getElementById('stickerText');
  const stickerEmoji = document.getElementById('stickerEmoji');
  const scaleRange = document.getElementById('scaleRange');
  const outlineToggle = document.getElementById('outlineToggle');
  const outlineThickness = document.getElementById('outlineThickness');
  const packCountEl = document.getElementById('packCount');

  // State
  let uploadedImageBase64 = null;
  let originalImage = null;
  let pack = [];
  let lastGeneratedDataUrl = null;

  // API (put your key here to enable server AI)
  const apiKey = ""; // <-- Add your Gemini key here (optional)
  const MODEL_NAME = "gemini-2.5-flash-image-preview";
  const API_URL = apiKey ? `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}` : null;

  // Helpers
  function showStatus(text, isError=false) {
    statusMessage.textContent = text || "";
    statusMessage.classList.toggle('text-red-600', !!isError);
  }
  function setProcessingState(isProcessing) {
    generateBtn.disabled = isProcessing || !uploadedImageBase64;
    loadingSpinner.classList.toggle('hidden', !isProcessing);
    generateIcon.classList.toggle('hidden', isProcessing);
    generateText.textContent = isProcessing ? 'Processing...' : 'Generate Sticker';
    if (isProcessing) showStatus('Processing image...'); else if (!isProcessing) showStatus('');
  }
  function isSupportedImageType(type) {
    return /^image\/(png|jpeg|webp)$/i.test(type);
  }
  function convertToBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = () => reject(new Error('File read error'));
      reader.onload = () => {
        const res = reader.result;
        const c = res.indexOf(',');
        resolve({ data: res.slice(c+1), mimeType: file.type || 'image/png' });
      };
      reader.readAsDataURL(file);
    });
  }
  function computeFitRect(imgW, imgH, canvasW, canvasH, scale=1) {
    const ratio = Math.min((canvasW / imgW) * scale, (canvasH / imgH) * scale);
    const dw = imgW * ratio, dh = imgH * ratio;
    const dx = (canvasW - dw) / 2, dy = (canvasH - dh) / 2;
    return {dx,dy,dw,dh,ratio};
  }
  function drawCheckerboard(ctx, size=16) {
    const w = ctx.canvas.width, h = ctx.canvas.height;
    for (let y=0;y<h;y+=size) {
      for (let x=0;x<w;x+=size) {
        ctx.fillStyle = ((Math.floor(x/size)+Math.floor(y/size))%2===0) ? '#e6edf3' : '#ffffff';
        ctx.fillRect(x,y,size,size);
      }
    }
  }

  // Drawing
  function drawPreview(img) {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawCheckerboard(ctx);
    const scale = parseFloat(scaleRange.value) || 1;
    const fit = computeFitRect(img.width, img.height, canvas.width, canvas.height, scale);
    ctx.drawImage(img, fit.dx, fit.dy, fit.dw, fit.dh);

    // Outline if enabled (visual only)
    if (outlineToggle.checked) {
      ctx.save();
      ctx.lineWidth = parseInt(outlineThickness.value || 12, 10);
      ctx.strokeStyle = 'white';
      // draw rounded rect stroke around fitted image area
      roundRectStroke(ctx, fit.dx - ctx.lineWidth/2, fit.dy - ctx.lineWidth/2, fit.dw + ctx.lineWidth, fit.dh + ctx.lineWidth, 24);
      ctx.restore();
    }
  }

  function roundRectStroke(ctx, x, y, w, h, r=12) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    ctx.stroke();
  }

  function drawOverlay(type) {
    if (!originalImage) return;
    drawPreview(originalImage);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    if (type === 'text') {
      const text = (stickerText.value || '').trim();
      if (!text) return;
      ctx.font = 'bold 60px Inter, sans-serif';
      ctx.lineWidth = 8;
      ctx.strokeStyle = 'black';
      ctx.fillStyle = 'white';
      ctx.strokeText(text.toUpperCase(), canvas.width/2, canvas.height * 0.88);
      ctx.fillText(text.toUpperCase(), canvas.width/2, canvas.height * 0.88);
    } else if (type === 'emoji') {
      const e = (stickerEmoji.value || '').trim();
      if (!e) return;
      ctx.font = '110px Inter, sans-serif';
      ctx.fillText(e, canvas.width * 0.82, canvas.height * 0.16);
    }
  }

  // Local cartoonify fallback (posterize + edges)
  function posterizeCanvasFromImage(img, levels = 6) {
    const tmp = document.createElement('canvas');
    tmp.width = 512; tmp.height = 512;
    const tctx = tmp.getContext('2d');
    tctx.drawImage(img, 0, 0, tmp.width, tmp.height);
    const id = tctx.getImageData(0,0,tmp.width,tmp.height);
    for (let i=0;i<id.data.length;i+=4) {
      for (let c=0;c<3;c++){
        const v = id.data[i+c];
        const q = Math.floor((v/255)*(levels-1)) * (255/(levels-1));
        id.data[i+c] = q;
      }
    }
    tctx.putImageData(id,0,0);
    return tmp;
  }
  function edgeDetectCanvas(srcCanvas) {
    const w = srcCanvas.width, h = srcCanvas.height;
    const sctx = srcCanvas.getContext('2d');
    const src = sctx.getImageData(0,0,w,h);
    const out = sctx.createImageData(w,h);
    for (let y=1;y<h-1;y++) {
      for (let x=1;x<w-1;x++) {
        let sum = 0;
        for (let ky=-1;ky<=1;ky++) for (let kx=-1;kx<=1;kx++) {
          const idx = ((y+ky)*w + (x+kx))*4;
          const gray = (src.data[idx] + src.data[idx+1] + src.data[idx+2]) / 3;
          sum += gray * ((kx===0 && ky===0) ? -8 : 1);
        }
        const oidx = (y*w + x)*4;
        const val = Math.max(0, Math.min(255, Math.abs(sum)));
        out.data[oidx] = out.data[oidx+1] = out.data[oidx+2] = 255 - val;
        out.data[oidx+3] = 255;
      }
    }
    const eCanvas = document.createElement('canvas');
    eCanvas.width = w; eCanvas.height = h;
    eCanvas.getContext('2d').putImageData(out, 0, 0);
    return eCanvas;
  }

  async function inBrowserCartoonify(img) {
    showStatus('Running local cartoonify (fallback)...');
    const poster = posterizeCanvasFromImage(img, 6);
    const edges = edgeDetectCanvas(poster);
    const out = document.createElement('canvas');
    out.width = 512; out.height = 512;
    const octx = out.getContext('2d');
    octx.drawImage(poster, 0, 0, out.width, out.height);
    octx.globalCompositeOperation = 'multiply';
    octx.drawImage(edges, 0, 0, out.width, out.height);
    octx.globalCompositeOperation = 'source-over';

    // make background transparent by sampling corners
    const id = octx.getImageData(0,0,out.width,out.height);
    function sample(x,y){ const idx=(y*out.width+x)*4; return [id.data[idx],id.data[idx+1],id.data[idx+2]]; }
    const c1 = sample(2,2), c2 = sample(out.width-3,2), c3 = sample(2,out.height-3), c4 = sample(out.width-3,out.height-3);
    const bg = [(c1[0]+c2[0]+c3[0]+c4[0])/4, (c1[1]+c2[1]+c3[1]+c4[1])/4, (c1[2]+c2[2]+c3[2]+c4[2])/4];
    for (let i=0;i<id.data.length;i+=4){
      const dr = id.data[i]-bg[0], dg = id.data[i+1]-bg[1], db = id.data[i+2]-bg[2];
      const dist = Math.sqrt(dr*dr + dg*dg + db*db);
      if (dist < 90) id.data[i+3] = 0;
    }
    octx.putImageData(id,0,0);
    return out;
  }

  // Fetch with backoff
  async function fetchWithExponentialBackoff(url, options, maxRetries = 4) {
    for (let i=0;i<maxRetries;i++) {
      try {
        const r = await fetch(url, options);
        if (r.status === 429) { await new Promise(res => setTimeout(res, Math.pow(2,i)*1000 + Math.random()*300)); continue; }
        return r;
      } catch (e) { await new Promise(res => setTimeout(res, Math.pow(2,i)*500)); }
    }
    throw new Error('Network error after retries');
  }

  // Generate logic
  async function prepareAndGenerate() {
    const selectedType = document.querySelector('input[name="stickerType"]:checked').value;
    actionButtons.classList.add('hidden');
    if (!uploadedImageBase64) { showStatus('Please upload an image first.', true); return; }
    if (selectedType === 'cartoon') {
      await generateAISticker();
    } else {
      const val = selectedType === 'text' ? (stickerText.value||'').trim() : (stickerEmoji.value||'').trim();
      if (!val) { showStatus(`Please enter the ${selectedType} before generating.`, true); return; }
      drawOverlay(selectedType);
      actionButtons.classList.remove('hidden');
      showStatus('Sticker generated!');
    }
  }

  async function generateAISticker() {
    setProcessingState(true);

    // If no server key, run local fallback
    if (!API_URL) {
      try {
        const fallbackCanvas = await inBrowserCartoonify(originalImage);
        const img = new Image();
        await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = fallbackCanvas.toDataURL('image/png'); });
        originalImage = img;
        drawPreview(originalImage);
        actionButtons.classList.remove('hidden');
        showStatus('âœ¨ Cartoon sticker ready (local).');
      } catch (err) {
        console.error('Local cartoonify failed', err);
        showStatus('Local cartoonify failed.', true);
      } finally { setProcessingState(false); }
      return;
    }

    // Server path
    const prompt = "Convert subject into vibrant cartoon sticker. Remove background. Output transparent PNG 512x512.";
    const payload = {
      contents: [{
        parts: [
          { text: prompt },
          { inlineData: { mimeType: fileInput.dataset.mimeType || 'image/png', data: uploadedImageBase64 } }
        ]
      }],
      generationConfig: { responseModalities: ['IMAGE'] }
    };

    try {
      showStatus('Sending image to AI server...');
      const response = await fetchWithExponentialBackoff(API_URL, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(payload)
      }, 4);

      const json = await response.json();
      const base64Data = json?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
      if (!base64Data) {
        showStatus('AI returned no image. Running local fallback.', true);
        const fallback = await inBrowserCartoonify(originalImage);
        const img = new Image();
        await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = fallback.toDataURL('image/png'); });
        originalImage = img;
        drawPreview(originalImage);
        actionButtons.classList.remove('hidden');
        setProcessingState(false);
        return;
      }

      const imageUrl = `data:image/png;base64,${base64Data}`;
      const aiImg = new Image();
      await new Promise((res, rej) => { aiImg.onload = res; aiImg.onerror = rej; aiImg.src = imageUrl; });
      originalImage = aiImg;
      drawPreview(originalImage);
      actionButtons.classList.remove('hidden');
      showStatus('âœ¨ Cartoon sticker ready!');
    } catch (err) {
      console.error('AI error', err);
      showStatus('AI call failed â€” running local fallback.', true);
      const fallback = await inBrowserCartoonify(originalImage);
      const img = new Image();
      await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = fallback.toDataURL('image/png'); });
      originalImage = img;
      drawPreview(originalImage);
      actionButtons.classList.remove('hidden');
    } finally {
      setProcessingState(false);
    }
  }

  // Compose export canvas (512x512) and return it
  function buildExportCanvas() {
    const tmp = document.createElement('canvas');
    tmp.width = 512; tmp.height = 512;
    const tctx = tmp.getContext('2d');
    tctx.clearRect(0,0,tmp.width,tmp.height);
    if (originalImage) {
      const fit = computeFitRect(originalImage.width, originalImage.height, tmp.width, tmp.height, parseFloat(scaleRange.value) || 1);
      tctx.drawImage(originalImage, fit.dx, fit.dy, fit.dw, fit.dh);
    }
    const selectedType = document.querySelector('input[name="stickerType"]:checked').value;
    if (selectedType === 'text' && stickerText.value.trim()) {
      tctx.font = 'bold 60px Inter, sans-serif';
      tctx.textAlign = 'center';
      tctx.fillStyle = 'white';
      tctx.strokeStyle = 'black';
      tctx.lineWidth = 8;
      tctx.strokeText(stickerText.value.toUpperCase(), tmp.width/2, tmp.height * 0.88);
      tctx.fillText(stickerText.value.toUpperCase(), tmp.width/2, tmp.height * 0.88);
    } else if (selectedType === 'emoji' && stickerEmoji.value.trim()) {
      tctx.font = '110px Inter, sans-serif';
      tctx.fillText(stickerEmoji.value.trim(), tmp.width * 0.82, tmp.height * 0.16);
    }
    return tmp;
  }

  function downloadSticker() {
    const out = buildExportCanvas();
    out.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ai-sticker.png';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showStatus('Download complete!');
    }, 'image/png');
  }

  async function shareSticker() {
    try {
      const out = buildExportCanvas();
      const blob = await new Promise(res => out.toBlob(res, 'image/png'));
      const file = new File([blob], 'ai-sticker.png', { type: 'image/png' });
      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({ files: [file], title: 'StickerGen AI', text: 'Check my sticker!' });
        showStatus('Shared successfully!');
      } else {
        showStatus('Sharing not supported on this device â€” downloading instead.');
        downloadSticker();
      }
    } catch (err) {
      console.error('Share error', err);
      showStatus('Sharing failed â€” download will start.', true);
      downloadSticker();
    }
  }

  // Pack features (JSZip)
  async function addToPack() {
    const out = buildExportCanvas();
    const blob = await new Promise(res => out.toBlob(res, 'image/png'));
    pack.push(blob);
    packCountEl.textContent = pack.length;
    showStatus('Added to pack.');
  }
  function clearPack() {
    pack = [];
    packCountEl.textContent = 0;
    showStatus('Pack cleared.');
  }
  async function downloadPack() {
    if (!pack.length) { showStatus('Pack empty.', true); return; }
    showStatus('Preparing pack ZIP...');
    const zip = new JSZip();
    pack.forEach((b, i) => zip.file(`sticker_${i+1}.png`, b));
    const content = await zip.generateAsync({ type: 'blob' });
    const url = URL.createObjectURL(content);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'sticker-pack.zip';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    showStatus('Pack downloaded!');
  }

  // File input handling
  fileInput.addEventListener('change', async (e) => {
    try {
      const file = e.target.files?.[0];
      if (!file) { fileNameDisplay.textContent = 'No file selected.'; uploadedImageBase64 = null; generateBtn.disabled = true; ctx.clearRect(0,0,canvas.width,canvas.height); initialPrompt.classList.remove('hidden'); return; }
      if (!isSupportedImageType(file.type)) { fileNameDisplay.textContent = 'Error: Only JPG, PNG, WEBP supported.'; uploadedImageBase64 = null; generateBtn.disabled = true; ctx.clearRect(0,0,canvas.width,canvas.height); initialPrompt.classList.remove('hidden'); return; }
      fileNameDisplay.textContent = `File loaded: ${file.name}`;
      const {data, mimeType} = await convertToBase64(file);
      uploadedImageBase64 = data;
      fileInput.dataset.mimeType = mimeType;
      const obj = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { originalImage = img; drawPreview(img); URL.revokeObjectURL(obj); generateBtn.disabled = false; actionButtons.classList.add('hidden'); initialPrompt.classList.add('hidden'); showStatus('Ready to generate!'); };
      img.onerror = () => { showStatus('Error loading image.', true); URL.revokeObjectURL(obj); };
      img.src = obj;
    } catch (err) {
      console.error(err);
      showStatus('Failed to read file.', true);
    }
  });

  // Controls toggle
  function updateControls() {
    const selectedType = document.querySelector('input[name="stickerType"]:checked').value;
    textInputGroup.classList.toggle('hidden', selectedType !== 'text');
    emojiInputGroup.classList.toggle('hidden', selectedType !== 'emoji');
    if (originalImage) { drawPreview(originalImage); actionButtons.classList.add('hidden'); }
  }
  updateControls();
  generateBtn.disabled = true;

  // expose some functions globally used by onclick attributes
  window.prepareAndGenerate = prepareAndGenerate;
  window.downloadSticker = downloadSticker;
  window.shareSticker = shareSticker;
  window.addToPack = addToPack;
  window.clearPack = clearPack;
  window.downloadPack = downloadPack;
  window.updateControls = updateControls;
  </script>
</body>
</html>
