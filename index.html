<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  
  <!-- SEO & Meta Tags -->
  <title>CropXPro ‚Äî Free AI Reels Maker, Splitter & Thumbnail Tool</title>
  <meta name="description" content="All-in-one Creator Studio: Auto-crop videos for Reels/TikTok, Split videos for WhatsApp Status, and Generate Thumbnails instantly. Free, No Login, Secure." />
  
  <!-- Fonts & Icons -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght=400;500;700;800&family=Inter:wght=400;500;600&display=swap" rel="stylesheet">

  <style>
    :root {
      --primary: #6366f1; /* Indigo */
      --secondary: #ec4899; /* Pink */
      --success: #10b981; /* Emerald Green */
      --bg: #0f172a;
      --surface: #1e293b;
      --surface-hover: #334155;
      --text: #f8fafc;
      --text-muted: #94a3b8;
      --radius: 12px;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    h1, h2, h3 { font-family: 'Outfit', sans-serif; margin: 0; }

    /* Header */
    header {
      width: 100%;
      padding: 20px;
      background: rgba(15, 23, 42, 0.95);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      position: sticky; top: 0; z-index: 50;
      display: flex; justify-content: center;
    }
    .header-inner {
      width: 100%; max-width: 1200px;
      display: flex; justify-content: space-between; align-items: center;
    }
    .logo { display: flex; align-items: center; gap: 10px; }
    .logo-box {
      width: 40px; height: 40px;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      border-radius: 10px;
      display: flex; align-items: center; justify-content: center;
      font-weight: 800; font-size: 20px;
    }

    /* Ad Slots */
    .ad-slot {
      width: 100%; max-width: 1000px; height: 100px;
      background: rgba(255,255,255,0.02);
      border: 1px dashed rgba(255,255,255,0.1);
      margin: 20px 0;
      display: flex; align-items: center; justify-content: center;
      color: var(--text-muted); font-size: 12px;
      border-radius: var(--radius);
    }

    /* Main Layout */
    main {
      width: 100%; max-width: 1200px;
      padding: 20px;
      display: grid; grid-template-columns: 1fr; gap: 20px;
    }

    /* Tabs */
    .tabs {
      display: flex; gap: 10px; margin-bottom: 20px;
      overflow-x: auto; padding-bottom: 5px;
    }
    .tab-btn {
      background: var(--surface);
      color: var(--text-muted);
      border: 1px solid rgba(255,255,255,0.05);
      padding: 12px 24px;
      border-radius: 50px;
      cursor: pointer;
      font-weight: 600;
      white-space: nowrap;
      transition: all 0.3s;
    }
    .tab-btn.active {
      background: var(--primary);
      color: white;
      box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
    }

    /* Cards */
    .tool-section { display: none; }
    .tool-section.active { display: block; animation: fadeIn 0.4s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); }}

    .grid-layout {
      display: grid; grid-template-columns: 1fr 350px; gap: 24px;
    }
    @media(max-width: 900px) { .grid-layout { grid-template-columns: 1fr; } }

    .card {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 24px;
      border: 1px solid rgba(255,255,255,0.05);
    }

    /* Components */
    .btn {
      background: linear-gradient(135deg, var(--primary), #4338ca); /* Darker primary for gradient end */
      color: white; border: none;
      padding: 12px 20px; border-radius: 8px;
      font-weight: 600; cursor: pointer;
      width: 100%; margin-top: 15px;
      transition: transform 0.2s;
    }
    .btn:hover:not(:disabled) { transform: scale(1.02); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
    
    .upload-zone {
      border: 2px dashed rgba(255,255,255,0.2);
      border-radius: var(--radius);
      padding: 40px; text-align: center;
      cursor: pointer; transition: all 0.5s;
    }
    .upload-zone:hover { background: rgba(255,255,255,0.02); border-color: var(--primary); }
    
    /* Visual Feedback for Upload */
    .upload-zone.uploaded {
      background: rgba(16, 185, 129, 0.1); /* Subtle green/teal */
      border-color: var(--success); /* Emerald green */
    }
    .upload-zone.uploaded:hover {
        background: rgba(16, 185, 129, 0.2);
    }

    .file-item {
      display: flex; justify-content: space-between; align-items: center;
      background: rgba(0,0,0,0.2); padding: 10px;
      margin-top: 10px; border-radius: 8px;
    }
    .delete-btn {
        background: none;
        border: none;
        color: #ef4444; /* Red */
        font-weight: 700;
        cursor: pointer;
        padding: 0 5px;
        font-size: 16px;
        transition: color 0.2s;
        line-height: 1;
    }
    .delete-btn:hover {
        color: #f87171;
    }

    /* Thumb Tool Specific */
    .thumb-canvas-container {
      max-width: 100%; overflow: hidden;
      border-radius: 8px; border: 1px solid #333;
      margin-top: 20px;
    }
    video.thumb-source { width: 100%; max-height: 300px; background: #000; }

    /* Previews */
    .preview-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; margin-top: 20px; }
    .preview-item { background: #000; border-radius: 8px; overflow: hidden; }
    .preview-item video, .preview-item img { width: 100%; display: block; }
    .preview-actions { padding: 8px; background: #222; text-align: center; }
    .preview-actions button { font-size: 11px; padding: 4px 8px; }

    /* Log */
    #logArea { 
      font-family: monospace; font-size: 11px; color: var(--text-muted); 
      height: 100px; overflow-y: auto; background: rgba(0,0,0,0.3); 
      padding: 10px; border-radius: 8px; margin-top: 20px;
    }
    
    /* Modal Styling */
    .app-modal {
      display: none; position:fixed; top:0; left:0; width:100%; height:100%; 
      background:rgba(0,0,0,0.8); z-index:100; justify-content:center; align-items:center;
    }
    .modal-content {
      background:var(--surface); padding:30px; border-radius:20px; max-width:500px; 
      color:var(--text); width: 90%;
    }
    
    /* Footer */
    footer {
      margin-top: 40px; padding: 30px; border-top: 1px solid rgba(255,255,255,0.1);
      text-align: center; color: var(--text-muted); font-size: 13px;
    }
    
    .feature-check { margin: 8px 0; font-size: 13px; display: flex; align-items: center; gap: 8px; }
    input[type="checkbox"] { accent-color: var(--secondary); transform: scale(1.2); }

    .header-btns {
      display: flex; gap: 10px;
    }
    .header-btns button {
      width: auto; padding: 8px 16px; font-size: 12px; background: #333;
      border-radius: 8px; font-weight: 500;
      transition: background 0.2s;
    }
    .header-btns button:hover {
      background: #444;
    }
  </style>
</head>
<body>

  <header>
    <div class="header-inner">
      <div class="logo">
        <div class="logo-box">CX</div>
        <div>
          <h2>CropXPro</h2>
          <span style="font-size: 11px; color: var(--secondary); font-weight: 600;">CREATOR STUDIO</span>
        </div>
      </div>
      <div class="header-btns">
        <button onclick="document.getElementById('aboutModal').style.display='flex'">About</button>
        <button onclick="document.getElementById('privacyModal').style.display='flex'">Privacy</button>
      </div>
    </div>
  </header>

  <!-- Top Ad -->
  <div class="ad-slot">
    <!-- ADSENSE TOP BANNER HERE -->
    <span>Advertisement Space (Top Banner)</span>
  </div>

  <main>
    <!-- Tool Tabs -->
    <div class="tabs">
      <button class="tab-btn active" onclick="switchTab('cropper', event)">‚úÇÔ∏è AI Auto-Crop</button>
      <button class="tab-btn" onclick="switchTab('splitter', event)">‚è±Ô∏è Reels Splitter</button>
      <button class="tab-btn" onclick="switchTab('thumb', event)">üñºÔ∏è Thumbnail Maker</button>
    </div>

    <!-- TOOL 1: AI CROPPER -->
    <div id="cropper" class="tool-section active">
      <div class="grid-layout">
        <div class="card">
          <h3>1. Upload & Settings</h3>
          <div class="upload-zone" id="cropDrop">
            <div style="font-size: 30px; margin-bottom: 10px;">‚òÅÔ∏è</div>
            <div>Drop horizontal videos here</div>
            <div style="font-size: 12px; color: var(--text-muted); margin-top:5px;">Max 10 mins recommended (Client-Side)</div>
          </div>
          <input type="file" id="cropInput" multiple accept="video/*" style="display:none">
          <div id="cropFileList"></div>

          <div style="margin-top: 25px;">
            <h4>Target Ratios</h4>
            <div style="display:flex; gap:15px; flex-wrap:wrap; margin-top:10px;">
              <label class="feature-check"><input type="checkbox" class="aspect-opt" value="9:16" checked> 9:16 (Reels/TikTok)</label>
              <label class="feature-check"><input type="checkbox" class="aspect-opt" value="1:1" checked> 1:1 (Square)</label>
              <label class="feature-check"><input type="checkbox" class="aspect-opt" value="4:5"> 4:5 (Portrait)</label>
              <label class="feature-check"><input type="checkbox" class="aspect-opt" value="16:9"> 16:9 (YouTube)</label>
            </div>
          </div>

          <div style="margin-top: 20px;">
            <h4>AI & Audio Enhancements</h4>
            <div style="display:flex; gap:15px; flex-wrap:wrap; margin-top:10px;">
              <label class="feature-check" title="Keeps subject somewhat centered"><input type="checkbox" id="optZoom"> üîç Smart Zoom</label>
              <label class="feature-check" title="Normalize audio loudness"><input type="checkbox" id="optAudioNorm"> üîä Audio Normalize</label>
              <label class="feature-check" title="Prevent crashes on long videos"><input type="checkbox" id="optSafeMode" checked> üõ°Ô∏è Safe Mode (Recommended)</label>
            </div>
          </div>

          <button id="startCropBtn" class="btn" disabled>‚ú® Start Batch Processing</button>
          
          <div id="logArea"></div>
        </div>

        <div class="card">
          <h3>Results</h3>
          <div id="cropResults" class="preview-list"></div>
          <!-- Side Ad -->
          <div class="ad-slot" style="height: 250px; margin-top:20px;">
            <!-- ADSENSE SIDEBAR HERE -->
            <span>Ad Space</span>
          </div>
        </div>
      </div>
    </div>

    <!-- TOOL 2: SPLITTER -->
    <div id="splitter" class="tool-section">
      <div class="card" style="max-width: 600px; margin: 0 auto;">
        <div style="text-align:center; margin-bottom:20px;">
          <h3>WhatsApp / Reels Splitter</h3>
          <p style="color:var(--text-muted); font-size:13px;">Split long videos into short, upload-ready segments.</p>
        </div>
        
        <div class="upload-zone" id="splitDrop">
          <div>Click to Upload Long Video</div>
        </div>
        <input type="file" id="splitInput" accept="video/*" style="display:none">
        <div id="splitFileDisplay" style="text-align:center; margin:10px; font-weight:600; color:var(--secondary);"></div>

        <div style="margin: 20px 0;">
          <label style="font-weight:600;">Segment Duration:</label>
          <select id="splitDuration" onchange="toggleCustomDuration(this.value)" style="width:100%; padding:10px; margin-top:5px; background:var(--bg); color:white; border:1px solid #444; border-radius:8px;">
            <option value="15">15 Seconds (WhatsApp Status)</option>
            <option value="30">30 Seconds (WhatsApp/Reels)</option>
            <option value="60">60 Seconds (Shorts)</option>
            <option value="custom">Custom Duration...</option>
          </select>
          <input type="number" id="customSplitDuration" placeholder="Enter duration in seconds (e.g., 10)" min="1" style="display:none; width:100%; padding:10px; margin-top:10px; background:var(--bg); color:white; border:1px solid #444; border-radius:8px; border-radius:8px;">
        </div>

        <button id="startSplitBtn" class="btn" disabled>‚úÇÔ∏è Split Video</button>
        <div id="splitResults" class="preview-list"></div>
      </div>
    </div>

    <!-- TOOL 3: THUMBNAIL -->
    <div id="thumb" class="tool-section">
      <div class="card" style="max-width: 600px; margin: 0 auto;">
          <div style="text-align:center; margin-bottom:20px;">
          <h3>Instant Thumbnail Generator</h3>
          <p style="color:var(--text-muted); font-size:13px;">Extract high-quality covers from your video. No upload to server.</p>
        </div>

        <input type="file" id="thumbInput" accept="video/*" style="width:100%; padding:10px; background:#333; border-radius:8px;">
        
        <div class="thumb-canvas-container">
          <video id="thumbVideo" class="thumb-source" playsinline muted></video>
        </div>

        <div style="margin-top:15px; display:flex; gap:10px; align-items:center;">
          <input type="range" id="thumbSlider" min="0" max="100" value="0" style="flex:1;">
          <span id="thumbTime" style="font-family:monospace;">00:00</span>
        </div>

        <button id="captureBtn" class="btn" style="background:var(--secondary);">üì∏ Capture & Download Frame</button>
      </div>
    </div>

  </main>

  <!-- MODAL: ABOUT/FEATURES -->
  <div id="aboutModal" class="app-modal">
    <div class="modal-content">
      <h3>About CropXPro</h3>
      <p>CropXPro is your free, secure, all-in-one Creator Studio for vertical video, running entirely in your browser.</p>
      <ul style="list-style-type: disc; margin-left: 20px; color: var(--text-muted);">
        <li>**AI Auto-Crop:** Instantly converts videos to 9:16 (Reels, TikTok) with Smart Zoom (Face Detection).</li>
        <li>**Reels Splitter:** Cut long videos into short segments (e.g., 15s, 30s) or define custom durations.</li>
        <li>**Thumbnail Maker:** Capture high-quality, frame-accurate cover images.</li>
        <li>**Performance:** Powered by WebAssembly (FFmpeg.wasm) for fast, local processing.</li>
      </ul>
      <button class="btn" onclick="document.getElementById('aboutModal').style.display='none'">Got It</button>
    </div>
  </div>

  <!-- MODAL: PRIVACY POLICY -->
  <div id="privacyModal" class="app-modal">
    <div class="modal-content">
      <h3>Privacy & Security</h3>
      <p>1. <strong>No Cloud Uploads:</strong> CropXPro processes videos locally in your browser using WebAssembly. Your files never leave your device.</p>
      <p>2. <strong>No Data Storage:</strong> We do not save your videos. Once you refresh, data is gone.</p>
      <p>3. <strong>AdSense:</strong> We use Google cookies for ads.</p>
      <button class="btn" onclick="document.getElementById('privacyModal').style.display='none'">Close</button>
    </div>
  </div>

  <!-- Bottom Ad -->
  <div class="ad-slot" style="margin: 0 auto;">
    <!-- ADSENSE BOTTOM BANNER HERE -->
    <span>Advertisement Space (Bottom)</span>
  </div>

  <footer>
    <p>¬© 2024 CropXPro Studio. All rights reserved.</p>
    <p style="opacity:0.5; font-size:11px;">Built for Creators. Not affiliated with Meta or Google.</p>
  </footer>

  <!-- Scripts: Using FFmpeg 0.11.6 (Stable) -->
  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

  <script>
    // --- APP LOGIC ---
    
    // 1. Navigation
    function switchTab(id, event) {
      document.querySelectorAll('.tool-section').forEach(el => el.classList.remove('active'));
      document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
      document.getElementById(id).classList.add('active');
      if (event && event.target) {
        event.target.classList.add('active');
      }
    }
    
    // Handle custom duration input visibility
    function toggleCustomDuration(value) {
      const customInput = document.getElementById('customSplitDuration');
      if (value === 'custom') {
        customInput.style.display = 'block';
        customInput.focus();
      } else {
        customInput.style.display = 'none';
      }
    }

    // 2. Variables & Init
    const { createFFmpeg, fetchFile } = FFmpeg;
    let ffmpeg = null;
    let cropFiles = [];
    let splitFile = null;

    const log = (msg) => {
      const el = document.getElementById('logArea');
      // Limit log entries to keep performance high
      if (el.children.length > 50) {
        el.removeChild(el.children[0]);
      }
      el.innerHTML += `<div>> ${msg}</div>`;
      el.scrollTop = el.scrollHeight;
    };

    // 3. Load Engine (FFmpeg Core Path Fix applied here)
    async function loadFFmpeg() {
      if(ffmpeg) return;
      log("Loading Engine (approx 30MB)...");
      try {
        // FIX: Ensure the corePath matches the main script version (0.11.6)
        ffmpeg = createFFmpeg({ log: true, corePath: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.11.6/dist/ffmpeg-core.js' });
        
        ffmpeg.setProgress(({ ratio }) => {
            // Update the log with progress
            if (ratio < 1) {
                log(`Processing: ${(ratio * 100).toFixed(1)}%`);
            }
        });

        await ffmpeg.load();
        log("Engine Ready ‚úÖ");
      } catch(e) {
        log("Error loading engine. Try Chrome/Desktop or refresh.");
        console.error("FFmpeg Load Error:", e);
      }
    }

    async function loadFaceAPI() {
      if(window.faceapi && !window.faceapi.nets.tinyFaceDetector.params) {
        log("Loading AI Models...");
        // Load the tiny face detector model
        // Note: face-api.js model folder must be present relative to the script
        await faceapi.nets.tinyFaceDetector.loadFromUri('https://cdn.jsdelivr.net/npm/@vladmandic/face-api@0.22.2/model/');
        log("AI Models Ready ‚úÖ");
      }
    }

    // --- TOOL 1: CROPPER LOGIC ---
    const cropDrop = document.getElementById('cropDrop');
    const cropInput = document.getElementById('cropInput');
    
    cropDrop.onclick = () => cropInput.click();
    cropInput.onchange = (e) => handleCropFiles(e.target.files);
    
    // Drag & Drop Handlers
    cropDrop.ondragover = (e) => { e.preventDefault(); cropDrop.style.borderColor = 'var(--secondary)'; };
    cropDrop.ondragleave = (e) => { 
        cropDrop.style.borderColor = cropFiles.length > 0 ? 'var(--success)' : 'rgba(255,255,255,0.2)'; 
    };
    cropDrop.ondrop = (e) => { 
        e.preventDefault(); 
        handleCropFiles(e.dataTransfer.files); 
    };

    // Renders the list of uploaded files, handles visual feedback, and button state
    function renderCropFileList() {
        const listEl = document.getElementById('cropFileList');
        const dropZone = document.getElementById('cropDrop');
        const startBtn = document.getElementById('startCropBtn');
        
        listEl.innerHTML = ''; // Clear current list
        
        if (cropFiles.length > 0) {
            dropZone.classList.add('uploaded');
            startBtn.disabled = false;
            
            cropFiles.forEach(item => {
                const div = document.createElement('div');
                div.className = 'file-item';
                div.setAttribute('data-id', item.id);
                div.innerHTML = `
                    <span style="flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${item.file.name}</span>
                    <small style="margin-right: 10px; color: var(--text-muted);">${(item.file.size/1024/1024).toFixed(1)}MB</small>
                    <button class="delete-btn" onclick="deleteCropFile('${item.id}')" title="Remove file">&times;</button>
                `;
                listEl.appendChild(div);
            });
        } else {
            dropZone.classList.remove('uploaded');
            startBtn.disabled = true;
        }
    }
    
    // Global function to delete a file from the list
    function deleteCropFile(id) {
        const initialLength = cropFiles.length;
        cropFiles = cropFiles.filter(item => item.id !== id);
        if (cropFiles.length < initialLength) {
            log(`Removed file ID: ${id}`);
        }
        renderCropFileList();
    }
    window.deleteCropFile = deleteCropFile; // Make globally accessible

    function handleCropFiles(files) {
      Array.from(files).forEach(file => {
        if (!file.type.startsWith('video/')) return;
        // Simple check to prevent duplicate uploads
        if (cropFiles.some(item => item.file.name === file.name && item.file.size === file.size)) {
             log(`Skipping potential duplicate file: ${file.name}`);
             return;
        }
        cropFiles.push({ file, id: Math.random().toString(36).substr(2,9) });
      });
      renderCropFileList();
    }

    async function detectFace(file) {
      return new Promise((resolve) => {
        const video = document.createElement('video');
        video.src = URL.createObjectURL(file);
        video.muted = true;
        video.style.display = 'none';
        document.body.appendChild(video);

        // Seek to the 2 second mark or middle of the video for detection
        video.onloadeddata = () => video.currentTime = Math.min(2, video.duration/2);
        video.onseeked = async () => {
          try {
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth; 
            canvas.height = video.videoHeight;
            canvas.getContext('2d').drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
            
            // Perform face detection using the tiny face detector
            const detection = await faceapi.detectSingleFace(canvas, new faceapi.TinyFaceDetectorOptions());
            
            // Clean up
            URL.revokeObjectURL(video.src);
            document.body.removeChild(video);
            
            resolve(detection ? { 
              x: detection.box.x + detection.box.width/2, // Center of face
              w: video.videoWidth 
            } : null);
          } catch(e) { 
            log(`Error during face detection for ${file.name}.`);
            console.error("Face API Error:", e);
            // Resolve null if any error occurs during detection
            resolve(null); 
          }
        };
        video.onerror = () => {
            document.body.removeChild(video);
            resolve(null);
        };
      });
    }

    document.getElementById('startCropBtn').onclick = async () => {
      const btn = document.getElementById('startCropBtn');
      btn.disabled = true;
      document.getElementById('cropResults').innerHTML = ''; // Clear old results
      await loadFFmpeg();

      if (!ffmpeg) {
        btn.disabled = false;
        return; // Stop if engine failed to load
      }
      
      const zoom = document.getElementById('optZoom').checked;
      if (zoom) await loadFaceAPI();

      const aspects = Array.from(document.querySelectorAll('.aspect-opt:checked')).map(c => c.value);
      const safeMode = document.getElementById('optSafeMode').checked;
      const normalize = document.getElementById('optAudioNorm').checked;

      for(const item of cropFiles) {
        log(`Processing ${item.file.name}...`);
        
        // 1. Face Detect (if enabled)
        let faceX = null;
        if(zoom) {
            const faceData = await detectFace(item.file);
            if(faceData) {
                faceX = faceData.x / faceData.w; // Normalized 0-1
                log(`  > Face detected at X: ${(faceX * 100).toFixed(0)}%`);
            } else {
                log(`  > No face detected. Defaulting to center crop.`);
            }
        }
        
        // 2. FFmpeg Write
        const inName = `in_${item.id}.mp4`;
        try {
            ffmpeg.FS('writeFile', inName, await fetchFile(item.file));
        } catch(e) {
            log(`ERROR: Could not write file to FFmpeg Virtual FS: ${e.message}`);
            continue;
        }

        for(const ratio of aspects) {
          const outName = `out_${item.id}_${ratio.replace(':','x')}.mp4`;
          const [tw, th] = ratio.split(':').map(Number);
          
          let filters = [];
          
          // Crop Logic
          let cropTxt = "";
          let xPos = "(iw-ow)/2"; // Default center
          
          if(faceX !== null) {
              // Formula: (video_width * normalized_face_x) - (output_width / 2)
              // Clamp xPos to ensure crop box doesn't go off screen (0 to iw-ow)
              xPos = `max(0, min(iw-ow, (iw*${faceX.toFixed(3)})-(ow/2)))`;
          }

          if(tw/th < 1) { // Vertical output (e.g., 9:16)
              // Crop height to be max possible, then restrict width to match aspect ratio
              cropTxt = `crop=w=min(iw, ih*(${tw}/${th})):h=ih:x=${xPos}:y=0`;
          } else { // Horizontal/Square output (e.g., 1:1, 16:9)
              // Crop width to be max possible, then restrict height to match aspect ratio
              cropTxt = `crop=w=iw:h=min(ih, iw*(${th}/${tw})):x=0:y=(ih-oh)/2`;
          }
          filters.push(cropTxt);

          // Safe Mode (Resize) - Resizing before crop helps with complex operations, target 720p height
          if(safeMode) filters.push("scale=-2:720"); 
          
          log(`  > Encoding ${ratio} for ${item.file.name}...`);
          
          // FFmpeg Arguments
          let args = ['-i', inName];
          args.push('-vf', filters.join(','));
          
          // Video quality settings (CRF 28 is high compression, faster)
          args.push('-c:v', 'libx264', '-preset', 'superfast', '-crf', '28');

          // Audio settings
          if(normalize) {
              // Loudnorm filter for audio normalization
              args.push('-af', 'loudnorm=I=-16:TP=-1.5:LRA=11'); 
          } else {
              args.push('-c:a', 'copy'); // Copy audio stream without re-encoding
          }
          args.push(outName);

          try {
              await ffmpeg.run(...args);
              // Read & Display
              const data = ffmpeg.FS('readFile', outName);
              addResult(new Blob([data.buffer], {type: 'video/mp4'}), `cropResults`, `${ratio}`);
              ffmpeg.FS('unlink', outName);
          } catch(e) {
              log(`ERROR during encoding ${ratio}: ${e.message}`);
          }
        }
        ffmpeg.FS('unlink', inName);
      }
      log("All batch processing tasks complete. ‚úÖ");
      btn.disabled = false;
    };

    // --- TOOL 2: SPLITTER LOGIC ---
    const splitDrop = document.getElementById('splitDrop');
    const splitInput = document.getElementById('splitInput');
    splitDrop.onclick = () => splitInput.click();
    splitInput.onchange = (e) => {
      if(e.target.files[0]) {
        splitFile = e.target.files[0];
        document.getElementById('splitFileDisplay').textContent = splitFile.name;
        document.getElementById('startSplitBtn').disabled = false;
        splitDrop.classList.add('uploaded');
      }
    };

    document.getElementById('startSplitBtn').onclick = async () => {
      const btn = document.getElementById('startSplitBtn');
      btn.disabled = true;
      document.getElementById('splitResults').innerHTML = ''; // Clear old results
      await loadFFmpeg();

      if (!ffmpeg || !splitFile) {
        btn.disabled = false;
        return;
      }
      
      const durationSelect = document.getElementById('splitDuration').value;
      const customDurationInput = document.getElementById('customSplitDuration');

      let dur = 0;
      if (durationSelect === 'custom') {
          dur = parseFloat(customDurationInput.value);
          if (isNaN(dur) || dur <= 1) {
              log("ERROR: Please enter a valid custom duration (> 1 second).");
              btn.disabled = false;
              return;
          }
      } else {
          dur = parseInt(durationSelect);
      }
      
      const inName = "split_in.mp4";
      log(`Writing file to memory: ${splitFile.name}`);
      ffmpeg.FS('writeFile', inName, await fetchFile(splitFile));
      
      let segmentIndex = 0;
      let start = 0;
      const maxSegments = 100; // Increase max segments for safety

      // Note: Splitting uses -c copy for fast, loss-less splitting.
      while(segmentIndex < maxSegments) {
        const outName = `seg_${segmentIndex+1}.mp4`;
        log(`Splitting segment ${segmentIndex+1} (Start: ${start.toFixed(1)}s, Duration: ${dur}s)...`);
        
        try {
          // -ss before -i for faster seeking; -t for duration; -c copy for speed
          const result = await ffmpeg.run('-ss', `${start}`, '-i', inName, '-t', `${dur}`, '-c', 'copy', outName);
          
          // Check if file size is non-zero (to detect end of video)
          const data = ffmpeg.FS('readFile', outName);
          if (data.length === 0) {
              log(`Segment ${segmentIndex+1} resulted in zero data. End of video reached.`);
              ffmpeg.FS('unlink', outName); // Clean up empty file
              break;
          }

          addResult(new Blob([data.buffer], {type:'video/mp4'}), 'splitResults', `Part ${segmentIndex+1}`);
          ffmpeg.FS('unlink', outName);
          
          start += dur;
          segmentIndex++;

        } catch(e) { 
          // Stop if error (likely end of video or ffmpeg error that we couldn't catch via file size)
          log(`Segment ${segmentIndex+1} failed or end of video reached unexpectedly.`);
          console.error("FFmpeg Split Error:", e);
          break; 
        } 
      }
      
      ffmpeg.FS('unlink', inName);
      btn.disabled = false;
      log("Split Complete ‚úÖ");
    };

    // --- TOOL 3: THUMBNAIL LOGIC (Canvas) ---
    const thumbInput = document.getElementById('thumbInput');
    const thumbVideo = document.getElementById('thumbVideo');
    const thumbSlider = document.getElementById('thumbSlider');
    
    thumbInput.onchange = (e) => {
      if (!e.target.files.length) return;
      // Revoke previous URL to free memory
      if (thumbVideo.src) URL.revokeObjectURL(thumbVideo.src); 

      const url = URL.createObjectURL(e.target.files[0]);
      thumbVideo.src = url;
      // Add visual feedback for the Thumbnail Tool upload
      document.querySelector('#thumb .card').style.backgroundColor = 'rgba(16, 185, 129, 0.1)';
      setTimeout(() => {
        document.querySelector('#thumb .card').style.backgroundColor = 'var(--surface)';
      }, 3000);
    };
    
    thumbVideo.onloadedmetadata = () => {
      thumbSlider.max = thumbVideo.duration;
      thumbSlider.value = 0; // Reset slider
      thumbVideo.currentTime = 0; // Go to start
    };
    
    thumbSlider.oninput = () => {
      // Ensure we seek only when paused or meta-loaded to prevent jumping
      if (thumbVideo.readyState >= 2) {
        thumbVideo.currentTime = thumbSlider.value;
      }
      const m = Math.floor(thumbVideo.currentTime/60);
      const s = Math.floor(thumbVideo.currentTime%60);
      document.getElementById('thumbTime').textContent = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    };
    
    thumbVideo.onseeked = () => {
        const m = Math.floor(thumbVideo.currentTime/60);
        const s = Math.floor(thumbVideo.currentTime%60);
        document.getElementById('thumbTime').textContent = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    };


    document.getElementById('captureBtn').onclick = () => {
      const canvas = document.createElement('canvas');
      canvas.width = thumbVideo.videoWidth;
      canvas.height = thumbVideo.videoHeight;
      canvas.getContext('2d').drawImage(thumbVideo, 0, 0, canvas.width, canvas.height);
      
      // Use the current timestamp in the filename
      const currentTimeFormatted = document.getElementById('thumbTime').textContent.replace(':', '-');

      canvas.toBlob(blob => {
        if (!blob) {
            log('Error capturing frame. Is the video fully loaded?');
            return;
        }
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `cropxpro_thumb_${currentTimeFormatted}.jpg`;
        a.click();
        
        // Clean up memory
        setTimeout(() => URL.revokeObjectURL(url), 2000);
      }, 'image/jpeg', 0.95); // High quality jpeg
    };

    // --- SHARED UTILS ---
    function addResult(blob, containerId, label) {
      const url = URL.createObjectURL(blob);
      const div = document.createElement('div');
      div.className = 'preview-item';
      // Use the URL helper for proper cleanup on download
      div.innerHTML = `
        <video controls playsinline muted src="${url}"></video>
        <div class="preview-actions">
          <strong>${label}</strong><br>
          <button class="btn" style="margin-top:5px; width:auto; padding:5px 10px;" onclick="window.downloadBlob('${url}', 'cropxpro_${label.replace(/\s/g, '_').toLowerCase()}.mp4')">‚¨áÔ∏è Save</button>
        </div>
      `;
      document.getElementById(containerId).appendChild(div);
    }

    window.downloadBlob = (url, name) => {
      const a = document.createElement('a');
      a.href = url; a.download = name; a.click();
      
      // Cleanup the object URL after download
      setTimeout(() => URL.revokeObjectURL(url), 2000); 
    };

    // Make utility functions globally accessible
    window.switchTab = switchTab;
    window.toggleCustomDuration = toggleCustomDuration;

  </script>
</body>
</html>
