<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>StickerGen AI â€” Create WhatsApp & Instagram Stickers (Cartoon, Text, Emoji)</title>

  <!-- Primary SEO -->
  <meta name="description" content="StickerGen AI instantly converts your photos into shareable WhatsApp & Instagram stickers â€” AI cartoonify with transparent PNG export, text & emoji overlays, and sticker-pack downloads. Client-side fallback ensures fast, private processing." />
  <meta name="keywords" content="sticker maker, whatsapp stickers, instagram stickers, cartoonify photo, transparent png, AI sticker, webp, sticker pack" />
  <link rel="canonical" href="https://www.example.com/" />

  <!-- Open Graph -->
  <meta property="og:title" content="StickerGen AI â€” Create WhatsApp Stickers" />
  <meta property="og:description" content="Turn your photos into shareable cartoon stickers. Transparent PNG, text & emoji overlays, sticker packs. No image storage." />
  <meta property="og:image" content="https://www.example.com/og-image.png" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://www.example.com/" />

  <!-- Twitter card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="StickerGen AI â€” Create WhatsApp Stickers" />
  <meta name="twitter:description" content="Turn photos into sticker-ready transparent PNGs with AI or client-side cartoonifier. Free and private." />
  <meta name="twitter:image" content="https://www.example.com/og-image.png" />

  <!-- Robots -->
  <meta name="robots" content="index,follow" />

  <!-- Structured data (JSON-LD): Organization, WebSite, Application, FAQ -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@graph": [
      {
        "@type": "Organization",
        "name": "StickerGen AI",
        "url": "https://www.example.com/",
        "logo": "https://www.example.com/logo.png",
        "sameAs": []
      },
      {
        "@type": "WebSite",
        "url": "https://www.example.com/",
        "name": "StickerGen AI",
        "description": "Create AI cartoon stickers and text/emoji overlays for WhatsApp & Instagram."
      },
      {
        "@type": "SoftwareApplication",
        "name": "StickerGen AI",
        "operatingSystem": "Web",
        "applicationCategory": "GraphicsApplication",
        "description": "Web-based sticker maker that cartoonifies photos, removes background, and exports transparent PNG stickers."
      },
      {
        "@type": "FAQPage",
        "mainEntity": [
          { "@type": "Question", "name": "Does StickerGen save my photos?", "acceptedAnswer": { "@type": "Answer", "text": "No â€” images are processed client-side where possible and not stored permanently. If you enable server AI, ensure your provider's policy meets your privacy needs." } },
          { "@type": "Question", "name": "Which file types are supported?", "acceptedAnswer": { "@type": "Answer", "text": "PNG, JPEG/JPG and WebP are supported." } }
        ]
      }
    ]
  }
  </script>

  <!-- Fonts & Tailwind -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- JSZip for sticker-pack export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" integrity="sha512-j6P/8o4HnOQ5pKc1uM3u1z8zrH6V7gYQHc6Bz1w1lC1mFfM6a3sZq+Jp/5lX0r3f0YQkzktm7ERkF7u6dVx7xA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <!-- ===== Customized Colorful Styles (only visual changes) ===== -->
  <style>
    :root{
      --bg-1: linear-gradient(135deg,#fff7f0 0%, #f3f0ff 100%);
      --accent-1: #ff6b6b;
      --accent-2: #6b8dff;
      --accent-3: #ffd166;
      --card-grad: linear-gradient(180deg, rgba(255,255,255,0.85), rgba(255,255,255,0.75));
      --glass: rgba(255,255,255,0.6);
    }

    html,body { height:100%; }
    body {
      font-family: 'Inter', system-ui, -apple-system, "Helvetica Neue", Arial;
      background: radial-gradient(circle at 10% 10%, rgba(255,107,107,0.06), transparent 10%),
                  radial-gradient(circle at 90% 90%, rgba(107,141,255,0.04), transparent 12%),
                  #f8fafc;
      color: #07203a;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* container card */
    .card {
      background: var(--card-grad);
      border: 1px solid rgba(15,23,42,0.04);
      box-shadow: 0 10px 30px rgba(8,20,60,0.07);
      border-radius: 16px;
    }

    header { padding: 22px 6px; margin-bottom: 8px; }
    header h1 {
      font-size: 2.4rem;
      letter-spacing: -0.02em;
      background: linear-gradient(90deg, var(--accent-1), var(--accent-2));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      display:inline-block;
    }
    header p { color: #334155; margin-top:6px; }

    /* Top ad styling */
    .ad-unit {
      border-radius: 14px;
      background: linear-gradient(135deg, rgba(255,209,136,0.12), rgba(107,141,255,0.06));
      display:flex; align-items:center; justify-content:center;
      border: 1px dashed rgba(16,24,40,0.06);
    }

    /* Controls column styling */
    .controls .label {
      color: #0f172a; font-weight:600;
    }
    input[type="file"] { background: linear-gradient(90deg,#fff,#fff); }
    .preview-box { height: 420px; border-radius: 12px; }

    /* Make buttons colorful & animated */
    .btn-primary {
      background: linear-gradient(90deg,var(--accent-1),var(--accent-2));
      color: white;
      box-shadow: 0 8px 20px rgba(107,141,255,0.12);
      transition: transform .12s ease, box-shadow .12s ease;
    }
    .btn-primary:hover { transform: translateY(-3px); box-shadow: 0 12px 34px rgba(107,141,255,0.18); }
    .btn-accent {
      background: linear-gradient(90deg,var(--accent-3),#ffd9a8);
      color: #07203a;
      font-weight:600;
      transition: transform .12s ease;
    }
    .btn-accent:hover { transform: translateY(-2px); }

    /* Colorful small UI elements */
    .chip {
      display:inline-flex; align-items:center; gap:8px;
      background: linear-gradient(90deg, rgba(255,255,255,0.9), rgba(255,255,255,0.7));
      border-radius: 999px; padding:6px 10px; font-weight:600; color:#0b2545;
      border: 1px solid rgba(11,37,69,0.05);
      box-shadow: 0 4px 14px rgba(11,37,69,0.04);
    }

    /* Make inputs pop */
    input, select, textarea { border-radius: 10px; border: 1px solid rgba(15,23,42,0.06); padding:10px; background: rgba(255,255,255,0.9); }
    input:focus, textarea:focus { outline: none; box-shadow: 0 6px 20px rgba(99,102,241,0.08); border-color: rgba(99,102,241,0.4); }

    /* Preview area */
    .preview-box { background: linear-gradient(180deg,#ffffff,#fbfdff); padding:14px; border: 1px solid rgba(15,23,42,0.03); }
    #stickerCanvas {
      width:100%; height:auto; max-width:560px; max-height:560px; border-radius:12px;
      border: 6px solid rgba(255,255,255,0.9);
      box-shadow: 0 12px 40px rgba(15,23,42,0.06), inset 0 -2px 12px rgba(11,37,69,0.02);
      transition: transform .12s ease;
    }

    #stickerCanvas:hover { transform: translateY(-4px) scale(1.01); }

    /* Status */
    #statusMessage { min-height: 20px; color: #334155; }

    /* Fancy small text */
    .muted { color:#64748b; font-size:0.92rem; }

    /* Action buttons */
    .action-row button { border-radius: 12px; padding:10px 12px; font-weight:700; }

    .rounded-glow {
      position:relative;
      border-radius:14px;
      overflow:hidden;
    }
    .rounded-glow:before {
      content:""; position:absolute; inset:0;
      background: linear-gradient(90deg, rgba(255,107,107,0.06), rgba(107,141,255,0.06));
      pointer-events:none;
    }

    /* Footer cards */
    footer .card { padding:18px; }

    /* Cookie consent styling improved */
    .cookie-consent { position: fixed; left: 12px; right: 12px; bottom: 12px; z-index: 9999; background: linear-gradient(90deg,#ffffff,#fffaf0); border-radius: 12px; padding: 12px; display:flex; align-items:center; gap:12px; border:1px solid rgba(11,37,69,0.06); box-shadow: 0 12px 40px rgba(11,37,69,0.08); }

    /* Responsive tweaks */
    @media (max-width: 900px) {
      header h1 { font-size: 1.9rem; }
      #stickerCanvas { max-width:420px; max-height:420px; border-width:5px; }
      .preview-box { height:360px; }
    }
  </style>
  <!-- ===== end visual-only styles ===== -->
</head>

<body class="p-4 md:p-8">
  <div class="container mx-auto max-w-6xl">
    <!-- Header -->
    <header class="text-center mb-6">
      <h1 class="text-4xl font-extrabold mb-1">ðŸš€ StickerGen AI</h1>
      <p class="text-gray-600 muted">Create WhatsApp & Instagram stickers in seconds â€” AI cartoonify, text & emoji overlays, transparent PNG export.</p>
    </header>

    <!-- Top Ad (Adaptive / 728x90) -->
    <div class="ad-unit h-24 md:h-28 rounded-lg flex items-center justify-center mb-6 card">
      <!-- Replace with your AdSense code -->
      <div class="chip"><svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M4 12h16" stroke="#6b8dff" stroke-width="2" stroke-linecap="round"/></svg><span class="muted">AD SENSE UNIT TOP (728x90 / Adaptive)</span></div>
    </div>

    <!-- Main grid -->
    <div class="grid lg:grid-cols-3 gap-8">
      <!-- Controls column -->
      <div class="lg:col-span-1 card p-6 controls rounded-glow">
        <h2 class="text-2xl font-semibold mb-4">1 â€” Upload & Customize</h2>

        <label class="block text-sm font-medium text-gray-700 mb-2">Select an Image (PNG / JPG / WEBP)</label>
        <input id="fileInput" type="file" accept="image/png,image/jpeg,image/webp" class="w-full text-sm mb-2" />
        <p id="fileNameDisplay" class="text-xs text-gray-500 italic mb-3">No file selected.</p>

        <div class="mb-3">
          <label class="text-sm font-medium text-gray-700">Sticker Type</label>
          <div class="flex gap-2 mt-2">
            <label class="flex items-center gap-2 p-2 rounded-lg cursor-pointer bg-gradient-to-r from-pink-50 to-blue-50 border border-transparent"><input name="stickerType" type="radio" value="cartoon" checked onchange="updateControls()" /> <span>âœ¨ AI Cartoon</span></label>
            <label class="flex items-center gap-2 p-2 rounded-lg cursor-pointer bg-gradient-to-r from-amber-50 to-lime-50"><input name="stickerType" type="radio" value="text" onchange="updateControls()" /> <span>ðŸ’¬ Text</span></label>
            <label class="flex items-center gap-2 p-2 rounded-lg cursor-pointer bg-gradient-to-r from-rose-50 to-cyan-50"><input name="stickerType" type="radio" value="emoji" onchange="updateControls()" /> <span>ðŸ˜‚ Emoji</span></label>
          </div>
        </div>

        <div id="customizationSection" class="space-y-3 mb-4">
          <div id="textInputGroup" class="hidden">
            <label class="text-sm font-medium">Sticker Text (max 20 chars)</label>
            <input id="stickerText" maxlength="20" class="w-full p-2 border rounded-lg" placeholder="E.g., HELLO!" />
            <label class="text-xs text-gray-500 mt-1">Short uppercase text works best.</label>
          </div>

          <div id="emojiInputGroup" class="hidden">
            <label class="text-sm font-medium">Emoji</label>
            <input id="stickerEmoji" maxlength="2" class="w-full p-2 border rounded-lg" placeholder="ðŸ”¥ or ðŸ˜Š" />
          </div>

          <div>
            <label class="text-sm font-medium">Scale</label>
            <input id="scaleRange" type="range" min="0.6" max="1.4" step="0.01" value="1" class="w-full" />
            <div class="flex items-center gap-3 text-xs text-gray-600 mt-1">
              <label class="flex items-center gap-2"><input id="outlineToggle" type="checkbox" /> Outline</label>
              <label class="flex items-center gap-2 text-xs">Thickness <input id="outlineThickness" type="range" min="0" max="24" value="12" class="w-24" /></label>
            </div>
          </div>

          <!-- NEW: Polish toggle -->
          <div class="mt-2 text-sm">
            <label class="flex items-center gap-2"><input id="polishToggle" type="checkbox" checked /> <span class="muted">Polish edges automatically (recommended)</span></label>
          </div>
        </div>

        <div class="mb-4">
          <button id="generateBtn" onclick="prepareAndGenerate()" class="w-full py-3 font-bold btn-primary rounded-xl disabled:opacity-50 flex items-center justify-center gap-2">
            <svg id="generateIcon" class="w-5 h-5" viewBox="0 0 24 24" fill="none"><path stroke="white" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
            <svg id="loadingSpinner" class="animate-spin w-5 h-5 hidden" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="white" stroke-width="4"></circle><path class="opacity-75" fill="white" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path></svg>
            <span id="generateText">Generate Sticker</span>
          </button>

          <!-- In-content ad (high RPM spot) -->
          <div class="my-3 bg-gradient-to-r from-white to-yellow-50 p-3 rounded-lg border border-yellow-100 text-center">
            <strong class="text-gray-600">AD SENSE (In-content) â€” paste AdSense code here</strong>
          </div>

          <p id="statusMessage" class="text-center text-sm mt-2 muted h-6"></p>
        </div>

        <div id="actionButtons" class="hidden flex gap-3 action-row">
          <button id="downloadBtn" onclick="downloadSticker()" class="flex-1 py-2 bg-white border border-gray-200 rounded-lg">Download PNG</button>
          <button id="addToPackBtn" onclick="addToPack()" class="flex-1 py-2 btn-accent rounded-lg">âž• Add to Pack</button>
          <button id="shareBtn" onclick="shareSticker()" class="flex-1 py-2" style="background:linear-gradient(90deg,#34d399,#60a5fa); color:#fff; border-radius:12px;">Share</button>
        </div>

        <div class="mt-4 space-y-2 text-xs muted">
          <div class="flex justify-between"><span>Pack items:</span><strong id="packCount">0</strong></div>
          <div class="flex gap-2">
            <button id="downloadPackBtn" onclick="downloadPack()" class="flex-1 py-2" style="background:linear-gradient(90deg,#7c3aed,#06b6d4); color:#fff; border-radius:12px;">Download Pack (ZIP)</button>
            <button onclick="clearPack()" class="py-2 px-3 bg-gray-100 rounded-lg">Clear</button>
          </div>
          <div class="text-xxs text-gray-500 mt-2">Tip: App runs locally if no server API key is configured.</div>
        </div>
      </div>

      <!-- Preview + Ads -->
      <div class="lg:col-span-2 space-y-6">
        <div class="card p-4 preview-box rounded-glow">
          <div class="flex items-center justify-between mb-3 px-2">
            <h3 class="text-lg font-semibold">2 â€” Sticker Preview</h3>
            <div class="text-sm text-gray-500 muted">Canvas: 512Ã—512 (export)</div>
          </div>

          <div class="relative h-full flex items-center justify-center rounded-xl p-3" style="background: linear-gradient(180deg,#fef3c7,#eff6ff); border:1px solid rgba(11,37,69,0.02);">
            <canvas id="stickerCanvas" width="512" height="512" class="shadow-inner"></canvas>
            <div id="initialPrompt" class="absolute text-center text-gray-600 pointer-events-none">
              <svg class="w-14 h-14 mx-auto mb-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
              <p>Upload a photo and click <strong>Generate Sticker</strong>.</p>
            </div>
          </div>
        </div>

        <!-- Native/medium rectangle ad -->
        <div class="ad-unit h-44 rounded-xl flex items-center justify-center card">
          <div class="chip"><svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M12 4v16" stroke="#ffd166" stroke-width="2" stroke-linecap="round"/></svg><span class="muted">AD SENSE UNIT (336x280 / Native)</span></div>
        </div>
      </div>
    </div>

    <!-- Footer ad & content -->
    <div class="mt-8 grid lg:grid-cols-2 gap-4">
      <div class="card p-4 rounded-glow">
        <h3 class="text-lg font-semibold mb-2">About StickerGen AI â€” SEO-friendly writeup</h3>
        <p class="text-sm muted leading-relaxed">
          StickerGen AI converts your photos into high-quality, transparent PNG stickers ready for WhatsApp and Instagram.
          Use the <strong>AI Cartoon</strong> mode for stylized cartoons, or use <strong>Text</strong> and <strong>Emoji</strong> modes to personalize stickers quickly.
          The app emphasizes privacy â€” processing happens client-side when possible and images are not stored on our servers.
          Export single stickers or build sticker packs (ZIP) for download.
        </p>
        <p class="text-xs text-gray-500 mt-3">Tip: Use short text (<=20 chars) and high-contrast photos for best cartoon results.</p>
      </div>

      <div class="card p-4 rounded-glow">
        <h3 class="text-lg font-semibold mb-2">AD SENSE (Footer) â€” Good RPM spot</h3>
        <div class="bg-gradient-to-r from-white to-slate-50 p-3 rounded border border-gray-100 text-center">
          <strong class="text-gray-600">AD SENSE UNIT (Footer) â€” paste AdSense snippet here</strong>
        </div>
      </div>
    </div>

    <footer class="mt-8 p-6 card rounded-glow">
      <div class="space-y-4">
        <h4 class="text-xl font-semibold">Privacy Policy & AdSense Compliance</h4>
        <p class="text-sm muted">Last Updated: Nov 29, 2025</p>

        <div class="text-sm text-gray-600 space-y-3">
          <strong>1. Data handling & No-Storage</strong>
          <p class="muted">StickerGen AI processes images client-side when possible. Uploaded images are used only to generate stickers and are not stored persistently by this site. If you configure a third-party AI server to process images (by adding an API key), images may be transmitted to that provider â€” ensure the provider's data policy meets your requirements before enabling server processing.</p>

          <strong>2. Third-party services & ads</strong>
          <p class="muted">We use Google AdSense to display ads. Google, as a third-party vendor, may use cookies to serve ads based on the user's previous visits to our site and other sites. To opt out of personalized ads, users may visit Google's Ads Settings. We do not sell personal data.</p>

          <strong>3. Third-party sharing</strong>
          <p class="muted">Sharing uses native Web Share APIs and external apps; we are not responsible for their data practices.</p>

          <strong>4. Rights & requests</strong>
          <p class="muted">If you wish to request deletion of stored data or exercise rights under GDPR/CCPA, contact the site owner at <em>privacy@example.com</em>. Note: by default the site does not store images; the email is for any account or analytic requests.</p>
        </div>
      </div>
    </footer>
  </div>

  <!-- Sticky bottom anchor ad (non-intrusive) -->
  <div id="stickyAd" class="hidden fixed bottom-4 left-4 right-4 md:left-auto md:right-12 md:bottom-12 z-50">
    <div class="bg-white p-3 rounded-lg shadow-lg border border-gray-200 flex items-center justify-between">
      <div class="text-sm text-gray-600">AD SENSE ANCHOR (mobile sticky) â€” paste code here</div>
      <button onclick="document.getElementById('stickyAd').style.display='none'" class="text-xs px-2 py-1 rounded bg-gray-100">Close</button>
    </div>
  </div>

  <!-- Cookie consent (simple) -->
  <div id="cookieConsent" class="cookie-consent hidden">
    <div class="flex-1 text-sm text-gray-800">We use cookies & third-party ads to improve experience and serve ads. By continuing you accept our <a href="#privacyPolicy" class="underline">privacy policy</a>.</div>
    <div class="flex gap-2">
      <button onclick="acceptCookies()" class="px-3 py-1" style="background:linear-gradient(90deg,#06b6d4,#7c3aed); color:#fff; border-radius:8px;">Accept</button>
      <button onclick="declineCookies()" class="px-3 py-1 bg-gray-100 rounded">Decline</button>
    </div>
  </div>

  <!-- MAIN SCRIPT (unchanged behavior + postprocessing) -->
  <script>
  /********** StickerGen AI â€” full script with post-processing **********/
  const canvas = document.getElementById('stickerCanvas');
  const ctx = canvas.getContext('2d');
  const fileInput = document.getElementById('fileInput');
  const generateBtn = document.getElementById('generateBtn');
  const actionButtons = document.getElementById('actionButtons');
  const statusMessage = document.getElementById('statusMessage');
  const loadingSpinner = document.getElementById('loadingSpinner');
  const generateIcon = document.getElementById('generateIcon');
  const generateText = document.getElementById('generateText');
  const initialPrompt = document.getElementById('initialPrompt');
  const fileNameDisplay = document.getElementById('fileNameDisplay');
  const packCountEl = document.getElementById('packCount');

  const textInputGroup = document.getElementById('textInputGroup');
  const emojiInputGroup = document.getElementById('emojiInputGroup');
  const stickerText = document.getElementById('stickerText');
  const stickerEmoji = document.getElementById('stickerEmoji');
  const scaleRange = document.getElementById('scaleRange');
  const outlineToggle = document.getElementById('outlineToggle');
  const outlineThickness = document.getElementById('outlineThickness');
  const polishToggle = document.getElementById('polishToggle');

  let uploadedImageBase64 = null;
  let originalImage = null;
  let pack = [];

  // API config (insert your key to enable server AI)
  const apiKey = ""; // <-- Add Gemini API key to enable server-based generation
  const MODEL_NAME = "gemini-2.5-flash-image-preview";
  const API_URL = apiKey ? `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}` : null;

  function showStatus(text, isError=false) {
    statusMessage.textContent = text || "";
    statusMessage.classList.toggle('text-red-600', !!isError);
  }
  function setProcessingState(isProcessing) {
    generateBtn.disabled = isProcessing || !uploadedImageBase64;
    loadingSpinner.classList.toggle('hidden', !isProcessing);
    generateIcon.classList.toggle('hidden', isProcessing);
    generateText.textContent = isProcessing ? 'Processing...' : 'Generate Sticker';
    if (isProcessing) showStatus('Processing image...'); else if (!isProcessing) showStatus('');
  }
  function isSupportedImageType(type) { return /^image\/(png|jpeg|webp)$/i.test(type); }

  function convertToBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = () => reject(new Error('File read error'));
      reader.onload = () => {
        const res = reader.result, c = res.indexOf(',');
        resolve({ data: res.slice(c+1), mimeType: file.type || 'image/png' });
      };
      reader.readAsDataURL(file);
    });
  }

  function computeFitRect(imgW, imgH, canvasW, canvasH, scale=1) {
    const ratio = Math.min((canvasW / imgW) * scale, (canvasH / imgH) * scale);
    const dw = imgW * ratio, dh = imgH * ratio;
    const dx = (canvasW - dw) / 2, dy = (canvasH - dh) / 2;
    return {dx,dy,dw,dh,ratio};
  }

  function drawCheckerboard(ctx, size=16) {
    const w = ctx.canvas.width, h = ctx.canvas.height;
    for (let y=0;y<h;y+=size) for (let x=0;x<w;x+=size) {
      ctx.fillStyle = ((Math.floor(x/size)+Math.floor(y/size))%2===0) ? '#e6edf3' : '#ffffff';
      ctx.fillRect(x,y,size,size);
    }
  }

  function drawPreview(img) {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawCheckerboard(ctx);
    const scale = parseFloat(scaleRange.value) || 1;
    const fit = computeFitRect(img.width, img.height, canvas.width, canvas.height, scale);
    ctx.drawImage(img, fit.dx, fit.dy, fit.dw, fit.dh);
    if (outlineToggle.checked) {
      ctx.save();
      ctx.lineWidth = parseInt(outlineThickness.value || 12, 10);
      ctx.strokeStyle = 'white';
      roundRectStroke(ctx, fit.dx - ctx.lineWidth/2, fit.dy - ctx.lineWidth/2, fit.dw + ctx.lineWidth, fit.dh + ctx.lineWidth, 24);
      ctx.restore();
    }
  }

  function roundRectStroke(ctx, x, y, w, h, r=12) {
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    ctx.stroke();
  }

  function drawOverlay(type) {
    if (!originalImage) return;
    drawPreview(originalImage);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    if (type === 'text') {
      const t = (stickerText.value || '').trim();
      if (!t) return;
      ctx.font = 'bold 60px Inter, sans-serif';
      ctx.lineWidth = 8;
      ctx.strokeStyle = 'black';
      ctx.fillStyle = 'white';
      ctx.strokeText(t.toUpperCase(), canvas.width/2, canvas.height * 0.88);
      ctx.fillText(t.toUpperCase(), canvas.width/2, canvas.height * 0.88);
    } else if (type === 'emoji') {
      const e = (stickerEmoji.value || '').trim();
      if (!e) return;
      ctx.font = '110px Inter, sans-serif';
      ctx.fillText(e, canvas.width * 0.82, canvas.height * 0.16);
    }
  }

  // --------- Post-processing helpers (feather, trim, outline, shadow) ----------
  // Simple box blur used for feathering mask (fast, approximate)
  function boxBlurGrayImageBuffer(src, w, h, radius) {
    if (radius < 1) return src;
    const rs = Math.ceil(radius);
    const tmp = new Uint8ClampedArray(src.length);
    // horizontal pass
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        let sum=0, count=0;
        const start = Math.max(0, x-rs), end = Math.min(w-1, x+rs);
        for (let k=start;k<=end;k++){ sum += src[y*w + k]; count++; }
        tmp[y*w + x] = Math.round(sum / count);
      }
    }
    const out = new Uint8ClampedArray(src.length);
    // vertical pass
    for (let x=0;x<w;x++){
      for (let y=0;y<h;y++){
        let sum=0, count=0;
        const start = Math.max(0, y-rs), end = Math.min(h-1, y+rs);
        for (let k=start;k<=end;k++){ sum += tmp[k*w + x]; count++; }
        out[y*w + x] = Math.round(sum / count);
      }
    }
    return out;
  }

  // Trim transparent border and center
  function trimAndCenterCanvas(srcCanvas, alphaThreshold=8) {
    const w = srcCanvas.width, h = srcCanvas.height;
    const ctx = srcCanvas.getContext('2d');
    const data = ctx.getImageData(0,0,w,h).data;
    let top=h, left=w, right=0, bottom=0;
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const i=(y*w+x)*4;
        const a = data[i+3];
        if (a > alphaThreshold) {
          if (x<left) left=x;
          if (x>right) right=x;
          if (y<top) top=y;
          if (y>bottom) bottom=y;
        }
      }
    }
    if (right < left || bottom < top) return srcCanvas;
    const nw = right-left+1, nh = bottom-top+1;
    const out = document.createElement('canvas'); out.width = out.height = 512;
    const octx = out.getContext('2d');
    const d = document.createElement('canvas'); d.width = nw; d.height = nh;
    d.getContext('2d').putImageData(ctx.getImageData(left, top, nw, nh), 0, 0);
    const fit = computeFitRect(nw, nh, out.width, out.height, 0.95);
    octx.clearRect(0,0,out.width,out.height);
    octx.drawImage(d, 0, 0, nw, nh, fit.dx, fit.dy, fit.dw, fit.dh);
    return out;
  }

  // Main post-process function: feather mask, apply alpha, add white outline + shadow
  async function postProcessCurrentImage(opts = {}) {
    const {
      feather = 6,
      outlineWidth = 10,
      shadowBlur = 18,
      shadowAlpha = 0.22
    } = opts;

    if (!originalImage) return;

    // Step A: draw original to temp 512 canvas (fitted)
    const tmp = document.createElement('canvas'); tmp.width = tmp.height = 512;
    const tctx = tmp.getContext('2d');
    tctx.clearRect(0,0,tmp.width,tmp.height);
    const fit = computeFitRect(originalImage.width, originalImage.height, tmp.width, tmp.height, parseFloat(scaleRange?.value||1));
    tctx.drawImage(originalImage, fit.dx, fit.dy, fit.dw, fit.dh);

    // Step B: create a grayscale mask: 0..255 (1 channel)
    const imgd = tctx.getImageData(0,0,tmp.width,tmp.height);
    const mask = new Uint8ClampedArray(tmp.width * tmp.height);
    for (let i=0, p=0;i<imgd.data.length;i+=4,p++){
      const r = imgd.data[i], g = imgd.data[i+1], b = imgd.data[i+2], a = imgd.data[i+3];
      // prefer alpha if provided, otherwise luminance threshold
      const lum = 0.299*r + 0.587*g + 0.114*b;
      const keep = a > 20 && lum > 6;
      mask[p] = keep ? 255 : 0;
    }

    // Step C: blur / feather mask
    const blurred = boxBlurGrayImageBuffer(mask, tmp.width, tmp.height, feather);

    // Step D: apply blurred mask as alpha to image
    for (let y=0;y<tmp.height;y++){
      for (let x=0;x<tmp.width;x++){
        const p = (y*tmp.width + x);
        const alpha = blurred[p];
        const idx = p*4;
        imgd.data[idx+3] = alpha;
      }
    }
    tctx.putImageData(imgd, 0, 0);

    // Step E: produce a "mask canvas" from blurred alpha for outline/shadow operations
    const maskCanvas = document.createElement('canvas'); maskCanvas.width = tmp.width; maskCanvas.height = tmp.height;
    const mctx = maskCanvas.getContext('2d');
    const maskImg = mctx.createImageData(tmp.width, tmp.height);
    for (let p=0, i=0;p<blurred.length;p++, i+=4){
      maskImg.data[i] = blurred[p];
      maskImg.data[i+1] = blurred[p];
      maskImg.data[i+2] = blurred[p];
      maskImg.data[i+3] = 255;
    }
    mctx.putImageData(maskImg, 0, 0);

    // Step F: final canvas with shadow + outline + image
    const final = document.createElement('canvas'); final.width = final.height = 512;
    const fctx = final.getContext('2d');
    fctx.clearRect(0,0,final.width,final.height);

    // shadow: draw blurred mask tinted black
    fctx.save();
    fctx.globalAlpha = shadowAlpha;
    fctx.filter = `blur(${shadowBlur}px)`;
    fctx.drawImage(maskCanvas, 0, 0);
    fctx.restore();

    // white outline: draw expanded mask by drawing mask multiple times (cheap stroke)
    if (outlineWidth > 0) {
      fctx.save();
      fctx.globalCompositeOperation = 'source-over';
      fctx.fillStyle = 'white';
      const off = Math.max(1, Math.round(outlineWidth/4));
      for (let xo = -off; xo <= off; xo++){
        for (let yo = -off; yo <= off; yo++){
          fctx.drawImage(maskCanvas, xo, yo);
        }
      }
      fctx.restore();
    }

    // draw processed image (with alpha)
    fctx.drawImage(tmp, 0, 0);

    // Step G: trim transparent padding and re-center
    const trimmed = trimAndCenterCanvas(final, 8);

    // Replace originalImage with processed result
    const dataURL = trimmed.toDataURL('image/png');
    const imgNew = new Image();
    await new Promise((res, rej) => { imgNew.onload = res; imgNew.onerror = rej; imgNew.src = dataURL; });
    originalImage = imgNew;
  }

  // --------- End post-processing helpers ----------

  async function fetchWithExponentialBackoff(url, options, maxRetries=4) {
    for (let i=0;i<maxRetries;i++) {
      try { const r = await fetch(url, options); if (r.status===429){ await new Promise(res=>setTimeout(res, Math.pow(2,i)*1000)); continue } return r; } catch(e) { await new Promise(res=>setTimeout(res, Math.pow(2,i)*500)); }
    }
    throw new Error('Network error after retries');
  }

  async function prepareAndGenerate() {
    const selectedType = document.querySelector('input[name="stickerType"]:checked').value;
    actionButtons.classList.add('hidden');
    if (!uploadedImageBase64) { showStatus('Please upload an image first.', true); return; }
    if (selectedType === 'cartoon') { await generateAISticker(); } else {
      const val = selectedType === 'text' ? (stickerText.value||'').trim() : (stickerEmoji.value||'').trim();
      if (!val) { showStatus(`Please enter the ${selectedType} before generating.`, true); return; }
      // For overlays, draw overlay then polish (optional)
      drawOverlay(selectedType);
      if (polishToggle && polishToggle.checked) {
        // build current canvas into originalImage and postprocess (keeps consistent flow)
        const tmpImg = new Image();
        tmpImg.src = canvas.toDataURL('image/png');
        await new Promise((res) => { tmpImg.onload = res; });
        originalImage = tmpImg;
        await postProcessCurrentImage({feather:6, outlineWidth:10, shadowBlur:14, shadowAlpha:0.2});
        drawPreview(originalImage);
      }
      actionButtons.classList.remove('hidden'); showStatus('Sticker generated!');
    }
  }

  async function generateAISticker() {
    setProcessingState(true);
    if (!API_URL) {
      try {
        const fallbackCanvas = await inBrowserCartoonify(originalImage);
        const img = new Image(); await new Promise((res,rej)=>{ img.onload=res; img.onerror=rej; img.src=fallbackCanvas.toDataURL('image/png'); });
        originalImage = img;
        // polish if enabled
        if (polishToggle && polishToggle.checked) {
          await postProcessCurrentImage({feather:6, outlineWidth:10, shadowBlur:16, shadowAlpha:0.22});
        }
        drawPreview(originalImage); actionButtons.classList.remove('hidden'); showStatus('âœ¨ Cartoon sticker ready (local).');
      } catch (err) { console.error(err); showStatus('Local cartoonify failed.', true); } finally { setProcessingState(false); }
      return;
    }

    const prompt = "Convert subject into vibrant cartoon sticker. Remove background. Output transparent PNG 512x512.";
    const payload = { contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: fileInput.dataset.mimeType || 'image/png', data: uploadedImageBase64 } }] }], generationConfig: { responseModalities: ['IMAGE'] } };

    try {
      showStatus('Sending to AI server...');
      const res = await fetchWithExponentialBackoff(API_URL, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) }, 4);
      const json = await res.json();
      const base64Data = json?.candidates?.[0]?.content?.parts?.find(p=>p.inlineData)?.inlineData?.data;
      if (!base64Data) {
        showStatus('AI returned no image. Running local fallback.', true);
        const fallback = await inBrowserCartoonify(originalImage); const img = new Image(); await new Promise((res,rej)=>{ img.onload=res; img.onerror=rej; img.src=fallback.toDataURL('image/png'); }); originalImage = img;
        if (polishToggle && polishToggle.checked) { await postProcessCurrentImage({feather:6, outlineWidth:10, shadowBlur:16, shadowAlpha:0.22}); }
        drawPreview(originalImage); actionButtons.classList.remove('hidden'); setProcessingState(false); return;
      }
      const imageUrl = `data:image/png;base64,${base64Data}`; const aiImg = new Image(); await new Promise((res,rej)=>{ aiImg.onload=res; aiImg.onerror=rej; aiImg.src=imageUrl; });
      originalImage = aiImg;
      if (polishToggle && polishToggle.checked) {
        await postProcessCurrentImage({feather:6, outlineWidth:10, shadowBlur:16, shadowAlpha:0.22});
      }
      drawPreview(originalImage); actionButtons.classList.remove('hidden'); showStatus('âœ¨ Cartoon sticker ready!');
    } catch (err) {
      console.error(err); showStatus('AI call failed â€” running local fallback.', true);
      const fallback = await inBrowserCartoonify(originalImage); const img = new Image(); await new Promise((res,rej)=>{ img.onload=res; img.onerror=rej; img.src=fallback.toDataURL('image/png'); }); originalImage = img;
      if (polishToggle && polishToggle.checked) { await postProcessCurrentImage({feather:6, outlineWidth:10, shadowBlur:16, shadowAlpha:0.22}); }
      drawPreview(originalImage); actionButtons.classList.remove('hidden');
    } finally { setProcessingState(false); }
  }

  function buildExportCanvas() {
    const tmp = document.createElement('canvas'); tmp.width=512; tmp.height=512; const tctx = tmp.getContext('2d'); tctx.clearRect(0,0,tmp.width,tmp.height);
    if (originalImage) { const fit = computeFitRect(originalImage.width, originalImage.height, tmp.width, tmp.height, parseFloat(scaleRange.value)||1); tctx.drawImage(originalImage, fit.dx, fit.dy, fit.dw, fit.dh); }
    const selectedType = document.querySelector('input[name="stickerType"]:checked').value;
    if (selectedType === 'text' && stickerText.value.trim()) { tctx.font='bold 60px Inter, sans-serif'; tctx.textAlign='center'; tctx.fillStyle='white'; tctx.strokeStyle='black'; tctx.lineWidth=8; tctx.strokeText(stickerText.value.toUpperCase(), tmp.width/2, tmp.height*0.88); tctx.fillText(stickerText.value.toUpperCase(), tmp.width/2, tmp.height*0.88); }
    else if (selectedType === 'emoji' && stickerEmoji.value.trim()) { tctx.font='110px Inter, sans-serif'; tctx.fillText(stickerEmoji.value.trim(), tmp.width * 0.82, tmp.height * 0.16); }
    return tmp;
  }

  function downloadSticker() {
    const out = buildExportCanvas();
    out.toBlob(blob=>{ const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='ai-sticker.png'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); showStatus('Download complete!'); }, 'image/png');
  }

  async function shareSticker() {
    try {
      const out = buildExportCanvas(); const blob = await new Promise(res=>out.toBlob(res, 'image/png'));
      const file = new File([blob], 'ai-sticker.png', { type: 'image/png' });
      if (navigator.canShare && navigator.canShare({ files: [file] })) { await navigator.share({ files: [file], title:'StickerGen AI', text:'Check my sticker!' }); showStatus('Shared successfully!'); }
      else { showStatus('Sharing not supported â€” downloading.'); downloadSticker(); }
    } catch (err) { console.error(err); showStatus('Share failed â€” downloading.', true); downloadSticker(); }
  }

  async function addToPack() {
    const out = buildExportCanvas(); const blob = await new Promise(res=>out.toBlob(res,'image/png')); pack.push(blob); packCountEl.textContent = pack.length; showStatus('Added to pack.'); }
  function clearPack(){ pack = []; packCountEl.textContent = 0; showStatus('Pack cleared.'); }
  async function downloadPack(){ if (!pack.length){ showStatus('Pack empty.', true); return; } showStatus('Preparing pack...'); const zip = new JSZip(); pack.forEach((b,i)=> zip.file(`sticker_${i+1}.png`, b)); const content = await zip.generateAsync({ type:'blob' }); const url = URL.createObjectURL(content); const a=document.createElement('a'); a.href=url; a.download='sticker-pack.zip'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); showStatus('Pack downloaded!'); }

  fileInput.addEventListener('change', async (e) => {
    try {
      const file = e.target.files?.[0]; if (!file){ fileNameDisplay.textContent='No file selected.'; uploadedImageBase64=null; generateBtn.disabled=true; ctx.clearRect(0,0,canvas.width,canvas.height); initialPrompt.classList.remove('hidden'); return; }
      if (!isSupportedImageType(file.type)){ fileNameDisplay.textContent='Error: Only PNG, JPG, WebP supported.'; uploadedImageBase64=null; generateBtn.disabled=true; ctx.clearRect(0,0,canvas.width,canvas.height); initialPrompt.classList.remove('hidden'); return; }
      fileNameDisplay.textContent = `File loaded: ${file.name}`; const {data, mimeType} = await convertToBase64(file); uploadedImageBase64 = data; fileInput.dataset.mimeType = mimeType;
      const obj = URL.createObjectURL(file); const img = new Image();
      img.onload = ()=>{ originalImage=img; drawPreview(img); URL.revokeObjectURL(obj); generateBtn.disabled=false; actionButtons.classList.add('hidden'); initialPrompt.classList.add('hidden'); showStatus('Ready to generate!'); };
      img.onerror = ()=>{ showStatus('Error loading image.', true); URL.revokeObjectURL(obj); };
      img.src = obj;
    } catch (err) { console.error(err); showStatus('Failed to read file.', true); }
  });

  function updateControls(){
    const selectedType = document.querySelector('input[name="stickerType"]:checked').value;
    textInputGroup.classList.toggle('hidden', selectedType !== 'text');
    emojiInputGroup.classList.toggle('hidden', selectedType !== 'emoji');
    if (originalImage){ drawPreview(originalImage); actionButtons.classList.add('hidden'); }
  }
  updateControls(); generateBtn.disabled = true;

  // Cookie consent simple handlers
  function acceptCookies(){ document.getElementById('cookieConsent').classList.add('hidden'); /* persist if desired */ }
  function declineCookies(){ document.getElementById('cookieConsent').classList.add('hidden'); /* disable personalized ads logic if implemented */ }
  window.acceptCookies = acceptCookies; window.declineCookies = declineCookies;

  // Expose functions to onclicks
  window.prepareAndGenerate = prepareAndGenerate;
  window.downloadSticker = downloadSticker;
  window.shareSticker = shareSticker;
  window.addToPack = addToPack;
  window.clearPack = clearPack;
  window.downloadPack = downloadPack;
  window.updateControls = updateControls;

  // Optionally show sticky ad small delay (non-intrusive)
  setTimeout(()=>{ const el=document.getElementById('stickyAd'); if (el) el.classList.remove('hidden'); }, 2500);
  // Optionally show cookie consent (only show if not previously accepted; simple demo)
  setTimeout(()=>{ const c=document.getElementById('cookieConsent'); if (c) c.classList.remove('hidden'); }, 1000);
  </script>
</body>
</html>
